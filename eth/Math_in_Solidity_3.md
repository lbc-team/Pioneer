# Solidity ä¸­çš„æ•°å­¦è¿ç®— (ç¬¬ä¸‰éƒ¨åˆ†: ç™¾åˆ†æ•°å’Œæ¯”ä¾‹è¿ç®—)

## æœ¬æ–‡æ˜¯ Solidity ä¸­è¿›è¡Œæ•°å­¦è¿ç®—ç³»åˆ—æ–‡ç« ä¸­çš„ç¬¬ä¸‰ç¯‡ï¼Œè¿™ç¯‡æ–‡ç« çš„ä¸»é¢˜æ˜¯: **ç™¾åˆ†æ•°å’Œæ¯”ä¾‹è¿ç®—**.

![](https://img.learnblockchain.cn/2020/08/13/15973037934793.jpg)

# å¼•è¨€

é‡‘èæ•°å­¦æœ€åŸºç¡€çš„å°±æ˜¯ç™¾åˆ†æ•°ã€‚ $x$ä¹˜ $y$çš„ç™¾åˆ†æ•°æ˜¯å¤šå°‘ï¼Ÿ $y$å $x$çš„ç™¾åˆ†æ¯”æ˜¯å¤šå°‘ï¼Ÿ æˆ‘ä»¬éƒ½çŸ¥é“ç­”æ¡ˆï¼š$x$ä¹˜$y$çš„ç™¾åˆ†æ•°æ˜¯ $xÃ—yÃ·100$, $y$æ˜¯$x$çš„ç™¾åˆ†ä¹‹: $yÃ—100Ã·x$ã€‚ æˆ‘ä»¬åœ¨æ•°å­¦è¯¾ä¸Šéƒ½å­¦è¿‡è¿™äº›ã€‚

The formulas above are particular cases of solving proportions. In general, proportion is an equation of the following form: $aÃ·b=cÃ·d$, and to solve the proportion is to find one of the values knowing the other three. For example, $d$ could be found from $a$, $b$, and $c$ like this: $d=bÃ—cÃ·a$.ä¸Šé¢çš„å…¬å¼æ˜¯è®¡ç®—æ¯”ä¾‹çš„ç‰¹ä¾‹ã€‚ é€šå¸¸æƒ…å†µä¸‹æ¯”ä¾‹æ˜¯ä»¥ä¸‹å½¢å¼çš„ç­‰å¼ï¼š$aÃ·b = cÃ·d$ï¼Œè®¡ç®—æ¯”ä¾‹å°±æ˜¯åœ¨å·²çŸ¥å…¶ä»–ä¸‰ä¸ªå€¼çš„æƒ…å†µä¸‹ç®—å‡ºç¬¬å››ä¸ªå€¼ã€‚ ä¾‹å¦‚ï¼Œå·²çŸ¥$a$, $b$å’Œ$c$æ±‚$d$, è®¡ç®—è¿‡ç¨‹å¦‚ä¸‹ï¼š$d = bÃ—cÃ·a$ã€‚

åœ¨ä¸»æµç¼–ç¨‹è¯­è¨€ä¸­è®¡ç®—è¿™ä¸ªæ¯”è¾ƒç®€å•ï¼Œè€Œåœ¨ Solidity ä¸­ï¼Œè¿™ç§è®¡ç®—ååˆ†å…·æœ‰æŒ‘æˆ˜æ€§æ€§ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨[æˆ‘ä»¬ä»¥å‰çš„æ–‡ç« ](/coinmonksmath-in-solidity-part-2-overflow-3cd7283714b4)æåŠçš„ä¸€æ ·ã€‚ ä¸»è¦æ˜¯ç”±ä¸¤ä¸ªåŸå› å¼•èµ·çš„: i) Solidity ä¸æ”¯æŒåˆ†æ•°ï¼› iiï¼‰Solidity ä¸­çš„æ•°å­—ç±»å‹å¯èƒ½ä¼šæº¢å‡º

In Javascript, one may calculate $xÃ—yÃ·z$ simple like this: `x*y/z`. In solidity such expression would not pass security audit, as for large enough $x$ and $y$ multiplication may overflow and thus calculation result may be incorrect. Using SafeMath doesnâ€™t help much, as it could make transaction to fail even when final calculation result would fit into 256 bits. In the previous article we called this situation â€œphantom overflowâ€. Doing division ahead of multiplication like `x/z*y` or `y/z*x` solves phantom overflow problem, but may lead to precision degradation.
åœ¨ Javascript ä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦å†™`x*y/z`å°±èƒ½è®¡ç®—$xÃ—yÃ·z$ã€‚ ç„¶è€Œåœ¨ Solidity ä¸­ï¼Œå¯¹äºè¶³å¤Ÿå¤§çš„$x$å’Œ$y$ä¹˜æ³•å¯èƒ½ä¼šæº¢å‡ºï¼Œå› æ­¤è®¡ç®—ç»“æœå¯èƒ½ä¸æ­£ç¡®ï¼Œè¿™æ ·çš„è¡¨è¾¾å¼ä¹Ÿå¾€å¾€ä¸èƒ½é€šè¿‡å®‰å…¨å®¡è®¡ã€‚ ä½¿ç”¨ SafeMath ä¹Ÿå¹¶å•¥ç”¨ï¼Œå› ä¸ºå®ƒå¯èƒ½å¯¼è‡´å³ä½¿æœ€ç»ˆè®¡ç®—ç»“æœåœ¨ 256 ä½ä»¥å†…ï¼Œäº¤æ˜“å´å¤±è´¥ã€‚ åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ç§°è¿™ç§æƒ…å†µä¸ºâ€œå‡æº¢å‡ºâ€ï¼ˆphantom overflowï¼‰ã€‚ åœ¨ä¹˜æ³•ä¹‹å‰å…ˆåšé™¤æ³•ï¼Œæ¯”å¦‚ `x/z*y` æˆ– `y/z*x` å¯ä»¥è§£å†³å‡æº¢å‡ºé—®é¢˜ï¼Œä½†è¿™å¯èƒ½å¯¼è‡´ç²¾åº¦é™ä½ã€‚

åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¼šé˜è¿°åœ¨ Solidity ä¸­æ›´å¥½åœ°å¤„ç†**åˆ†æ•°å’Œæ¯”ä¾‹**çš„æ–¹æ³•ã€‚

# ä¸€æ­¥æ­¥å®ç°æ¯”ä¾‹è®¡ç®—çš„â€œå®Œå…¨ä½“â€

æœ¬æ–‡çš„ç›®æ ‡æ˜¯åœ¨ Solidity ä¸­å®ç°ä»¥ä¸‹å‡½æ•°:

```
function mulDiv (uint x, uint y, uint z)
public pure returns (uint)
```

è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½æ˜¯,è®¡ç®—$xÃ—yÃ·z$ï¼Œå¹¶å°†ç»“æœå››èˆäº”å…¥ï¼ŒåŒæ—¶å¦‚æœ$z$ä¸ºé›¶ä¼šæŠ›å‡ºé”™è¯¯ã€‚ è®©æˆ‘ä»¬å…ˆä»ä»¥ä¸‹ç®€å•çš„æ–¹æ³•å¼€å§‹ï¼š

```
function mulDiv (uint x, uint y, uint z)
public pure returns (uint)
{
  return x * y / z;
}
```

è¿™ä¸ªæ–¹æ¡ˆåŸºæœ¬ä¸Šæ»¡è¶³å¤§å¤šæ•°è¦æ±‚ï¼šå®ƒçœ‹èµ·æ¥èƒ½è®¡ç®—å‡º$xÃ—yÃ·z$ï¼Œç„¶åå°†ç»“æœå››èˆäº”å…¥ï¼Œå¹¶åœ¨$z$ä¸ºé›¶çš„æƒ…å†µä¸‹æŠ›å‡ºé”™è¯¯ã€‚ ä½†æ˜¯ï¼Œæœ‰ä¸€ä¸ªé—®é¢˜æ˜¯ï¼šå®ƒå®é™…è®¡ç®—çš„æ˜¯$xÃ—y\mod \ 2 ^{256}Ã·z$ã€‚ è¿™å°±æ˜¯ Solidity ä¸­ä¹˜æ³•æº¢å‡ºçš„æœºåˆ¶ã€‚ å½“ä¹˜æ³•ç»“æœå¤§äº 256 ä½æ—¶ï¼Œä»…è¿”å›ç»“æœä¸­æœ€ä½çš„ 256 ä½ã€‚ å¯¹äºè¾ƒå°çš„$x$å’Œ$y$ï¼Œå½“$xÃ—y<2^ {256}$æ—¶ï¼Œè¿™æ²¡æœ‰åŒºåˆ«ï¼Œä½†æ˜¯å¯¹äºè¾ƒå¤§çš„$x$å’Œ$y$ä¼šäº§ç”Ÿé”™è¯¯çš„ç»“æœã€‚æ‰€ä»¥ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯ï¼š

## **æˆ‘ä»¬æ”¹å¦‚ä½•é¿å…æº¢å‡º?**

> æ€è·¯ï¼šä¸è®©å®ƒæº¢å‡ºã€‚

åœ¨ Solidity ä¸­é˜²æ­¢ä¹˜æ³•æº¢å‡ºçš„å¸¸ç”¨æ–¹æ³•æ˜¯ä½¿ç”¨ SafeMath åº“ä¸­çš„`mul`å‡½æ•°:

```
function mulDiv (uint x, uint y, uint z)
public pure returns (uint)
{
  return mul (x, y) / z;
}
```

è¯¥ä»£ç ä¿è¯äº†æ­£ç¡®çš„ç»“æœï¼Œæ‰€ä»¥ç°åœ¨æ‰€æœ‰çš„è¦æ±‚ä¼¼ä¹éƒ½æ»¡è¶³äº†ï¼Œå¯¹å§ï¼Ÿä½†å…¶å®è¿˜æ²¡å®Œã€‚ã€‚ã€‚

ç¨‹åºçš„è¦æ±‚æ˜¯åœ¨æº¢å‡ºæ—¶èƒ½å›æ»šï¼Œè¿™ä¸ªæ–¹æ¡ˆä¼¼ä¹å¯ä»¥æ»¡è¶³è¦æ±‚ã€‚ ä½†é—®é¢˜æ˜¯ï¼Œå³ä½¿æœ€ç»ˆçš„ç»“æœä¸ä¼šæº¢å‡ºï¼Œåªè¦$xÃ—y$æº¢å‡ºï¼Œç¨‹åºä¹Ÿä¼šå›æ»šã€‚ æˆ‘ä»¬ç§°è¿™ç§æƒ…å†µä¸ºâ€œå‡æº¢å‡ºâ€(â€œphantom overflowâ€)ã€‚ åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬ç»™å¤§å®¶å±•ç¤ºäº†å¦‚ä½•ä»¥ç²¾ç¡®åº¦ä¸ºä»£ä»·è§£å†³å‡æº¢å‡ºé—®é¢˜ï¼Œä½†æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦ç²¾ç¡®çš„ç»“æœï¼Œæ‰€ä»¥è¯¥è§£å†³æ–¹æ¡ˆåœ¨è¿™é‡Œè¡Œä¸é€šã€‚

ç”±äºæ— æ³•é¿å…å‡æº¢å‡ºï¼Œå› æ­¤

## æˆ‘ä»¬å¦‚ä½•åœ¨ä¿æŒç²¾åº¦çš„åŒæ—¶é¿å…å‡æº¢å‡º?

> æ€è·¯: ç®€å•çš„æ•°å­¦æŠ€å·§.

è®©æˆ‘ä»¬è¿›è¡Œä»¥ä¸‹æ›¿æ¢ï¼š$x=aÃ—z+b$ å’Œ $y=cÃ—z+d$ï¼Œå…¶ä¸­ $a, b, cå’Œ\ d$ æ˜¯æ•´æ•°ï¼Œä¸”$0â‰¤b<z$ã€‚é‚£ä¹ˆ:

$$
xÃ—yÃ·z=
(aÃ—z+b)Ã—(cÃ—z+d)Ã·z=
(aÃ—cÃ—z^2+(aÃ—d+bÃ—c)Ã—z+bÃ—d)Ã·z=
aÃ—bÃ—z+aÃ—d+bÃ—c+bÃ—dÃ·z
$$

$aï¼Œbï¼Œcå’Œ\ d$ çš„å€¼å¯åˆ†åˆ«ç”¨$x$å’Œ$y$å¯¹$z$æ±‚ä½™æ¥è®¡ç®—.

å› æ­¤ï¼Œå¯ä»¥è¿™æ ·é‡å†™è¯¥å‡½æ•°:

```
function mulDiv (uint x, uint y, uint z)
public pure returns (uint)
{
  uint a = x / z; uint b = x % z; // x = a * z + b
  uint c = y / z; uint d = y % z; // y = c * z + d return a * b * z + a * d + b * c + b * d / z;
}
```

åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ç®€å•çš„`+`å’Œ`*`è¿ç®—ç¬¦æ¥æé«˜å¯è¯»æ€§ï¼Œåœ¨çœŸå®ä»£ç åº”ä½¿ç”¨ SafeMath å‡½æ•°æ¥é˜²æ­¢çœŸæº¢å‡ºï¼ˆå³éå‡æº¢å‡ºï¼‰ã€‚

åœ¨æ­¤å®ç°ä¸­ï¼Œå‡æº¢å‡ºä»å¯èƒ½å­˜åœ¨ï¼Œä½†ä»…åœ¨æœ€åä¸€é¡¹`b * d / z`ä¸­ã€‚ä½†æ˜¯ï¼Œåªè¦ä¿è¯$zâ‰¤2^ {128}$ï¼Œæ­¤ä»£ç å°±æ²¡é—®é¢˜ï¼Œå› ä¸º$b$å’Œ$d$éƒ½å°äº$z$ï¼Œè¿™ä¿è¯äº†$bÃ—d$å¯ä»¥å®¹çº³ 256 ä½ã€‚ å› æ­¤ï¼Œå¯ä»¥åœ¨å·²çŸ¥$z$ä¸è¶…è¿‡ $2^{128}$ çš„æƒ…å†µä¸‹ä½¿ç”¨ã€‚ ä¸€ä¸ªå¸¸è§çš„ç¤ºä¾‹æ˜¯å›ºå®šä¹˜æ³•çš„å°æ•°ç‚¹ä½æ•°ä¸º 18 ä½ï¼š$xÃ—yÃ·10 ^ {18}$ã€‚ä½†æ˜¯ï¼Œ

## æˆ‘ä»¬åˆ°åº•å¦‚ä½•æ‰èƒ½å½»åº•é¿å…å‡æº¢å‡º?

> æ€è·¯: ä½¿ç”¨ä½æ•°æ›´å®½çš„æ•°å­—.

å‡æº¢å‡ºé—®é¢˜çš„æ ¹æºåœ¨äºä¸­é—´ä¹˜æ³•ç»“æœè¶…å‡º 256 ä½ã€‚ å› æ­¤ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ä½æ•°æ›´å®½çš„æ•°å­—ã€‚ Solidity æœ¬èº«ä¸æ”¯æŒå¤§äº 256 ä½çš„æ•°æ®ç±»å‹ï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»æ¨¡æ‹Ÿå®ƒä»¬ã€‚ æˆ‘ä»¬éœ€è¦ä¸¤ä¸ªåŸºæœ¬æ“ä½œï¼š$uintÃ—uintâ†’wide$å’Œ$wideÃ·uintâ†’uint$ã€‚

ç”±äºä¸¤ä¸ª 256 ä½æ— ç¬¦å·æ•´æ•°çš„ä¹˜ç§¯ä¸èƒ½è¶…è¿‡ 512 ä½ï¼Œå› æ­¤è¾ƒå®½çš„ç±»å‹å¿…é¡»è‡³å°‘ä¸º 512 ä½å®½ã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸¤ä¸ª 256 ä½$æ— ç¬¦å·æ•´æ•°å¯¹$æ¥æ¨¡æ‹Ÿ 512 ä½æ— ç¬¦å·æ•´æ•°ï¼Œè€Œè¿™ä¸¤ä¸ª 256 ä½æ— ç¬¦å·æ•´æ•°åˆ†åˆ«è¡¨ç¤ºæ•´ä¸ª 512 ä½æ•°å­—çš„è¾ƒä½å’Œè¾ƒé«˜ 256 ä½éƒ¨åˆ†ã€‚

å› æ­¤ï¼Œä»£ç å¯èƒ½çœ‹èµ·æ¥åƒè¿™æ ·:

```
function mulDiv (uint x, uint y, uint z)
public pure returns (uint)
{
  (uint l, uint h) = fullMul (x, y);
  return fullDiv (l, h, z);
}
```

è¿™é‡Œçš„`fullMul`å‡½æ•°å°†ä¸¤ä¸ª 256 ä½æ— ç¬¦å·æ•´æ•°ç›¸ä¹˜ï¼Œå¹¶å°† 512 ä½æ— ç¬¦å·æ•´æ•°çš„ç»“æœåˆ†æˆä¸¤ä¸ª 256 ä½æ•´æ•°çš„å½¢å¼è¿”å›ã€‚å‡½æ•°`fullDiv`é™¤ä»¥ä¸¤ä¸ª 256 ä½æ— ç¬¦å·æ•´æ•°å½¢å¼ä¼ é€’çš„ 512 ä½æ— ç¬¦å·æ•´æ•°ï¼Œå’Œä¸€ä¸ª 256 ä½æ— ç¬¦å·æ•´æ•°ï¼Œå¹¶ä»¥ 256 ä½æ— ç¬¦å·æ•´æ•°å½¢å¼è¿”å›ç»“æœã€‚

è®©æˆ‘ä»¬ç”¨å­¦æ ¡é‡Œå­¦çš„æ•°å­¦æ¥å®ç°è¿™ä¸¤ä¸ªå‡½æ•°ï¼š

```
function fullMul (uint x, uint y)
public pure returns (uint l, uint h)
{
  uint xl = uint128 (x); uint xh = x >> 128;
  uint yl = uint128 (y); uint yh = y >> 128;

  uint xlyl = xl * yl; uint xlyh = xl * yh;
  uint xhyl = xh * yl; uint xhyh = xh * yh;

  uint ll = uint128 (xlyl);
  uint lh = (xlyl >> 128) + uint128 (xlyh) + uint128 (xhyl);
  uint hl = uint128 (xhyh) + (xlyh >> 128) + (xhyl >> 128);
  uint hh = (xhyh >> 128);

  l = ll + (lh << 128);
  h = (lh >> 128) + hl + (hh << 128);
}
```

å’Œ

```
function fullDiv (uint l, uint h, uint z)
public pure returns (uint r) {
  require (h < z);

  uint zShift = mostSignificantBit (z);
  uint shiftedZ = z;
  if (zShift <= 127) zShift = 0;
  else
  {
    zShift -= 127;
    shiftedZ = (shiftedZ - 1 >> zShift) + 1;
  }

  while (h > 0)
  {
    uint lShift = mostSignificantBit (h) + 1;
    uint hShift = 256 - lShift;

    uint e = ((h << hShift) + (l >> lShift)) / shiftedZ;
    if (lShift > zShift) e <<= (lShift - zShift);
    else e >>= (zShift - lShift);

    r += e;

    (uint tl, uint th) = fullMul (e, z);
    h -= th;
    if (tl > l) h -= 1;
    l -= tl;
  }
  r += l / z;
}
```

è¿™é‡Œçš„`mostSignificantBit`æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒè¿”å›å‚æ•°æœ€é«˜æœ‰æ•ˆä½çš„ç´¢å¼•ï¼ˆä»é›¶å¼€å§‹ç´¢å¼•)ã€‚æ­¤å‡½æ•°å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å®ç°ï¼š

```
function mostSignificantBit (uint x) public pure returns (uint r) {
  require (x > 0);

  if (x >= 2**128) { x >>= 128; r += 128; }
  if (x >= 2**64) { x >>= 64; r += 64; }
  if (x >= 2**32) { x >>= 32; r += 32; }
  if (x >= 2**16) { x >>= 16; r += 16; }
  if (x >= 2**8) { x >>= 8; r += 8; }
  if (x >= 2**4) { x >>= 4; r += 4; }
  if (x >= 2**2) { x >>= 2; r += 2; }
  if (x >= 2**1) { x >>= 1; r += 1; }
}
```

ä¸Šé¢çš„ä»£ç å¾ˆå¤æ‚ï¼Œå¯èƒ½éœ€è¦ç»™å¤§å®¶è§£é‡Šï¼Œä½†æ˜¯æˆ‘ä»¬ç°åœ¨å°†ç•¥è¿‡è¿™äº›è§£é‡Šï¼Œè€Œå°†é‡ç‚¹å…ˆæ”¾åœ¨å…¶ä»–é—®é¢˜ä¸Šã€‚ è¿™æ®µä»£ç çš„é—®é¢˜åœ¨äºï¼Œæ¯æ¬¡è°ƒç”¨ mulDiv å‡½æ•°ä¼šæ¶ˆè€—é«˜è¾¾ 2.5K çš„ gasã€‚

## æˆ‘ä»¬å¯ä»¥æŠŠå®ƒå¼„å¾—ä¾¿å®œä¸€ç‚¹å—?

> æ€è·¯: æ•°å­¦!

ä»¥ä¸‹ä»£ç åŸºäº[Remco Bloemen](https://medium.com/u/da8bcc0c6bbc?source=post_page-----4db014e080b1----------------------)æå‡ºçš„æƒŠäººæ•°å­¦å‘ç°ï¼Œå¦‚æœæ‚¨å–œæ¬¢æ­¤ä»£ç ï¼Œè¯·ä¸ºä»–çš„â€œæ•°å­¦â€æ–‡ç« é¼“æŒ ğŸ‘ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬é‡å†™`fullMul`å‡½æ•°:

```
function fullMul (uint x, uint y)
public pure returns (uint l, uint h)
{
  uint mm = mulmod (x, y, uint (-1));
  l = x * y;
  h = mm - l;
  if (mm < l) h -= 1;
}
```

æ¯æ¬¡`fullMul`è°ƒç”¨å¯èŠ‚çœçº¦ 250 gas.

ç„¶åæˆ‘ä»¬é‡å†™`mulDiv`å‡½æ•°:

```
function mulDiv (uint x, uint y, uint z)
public pure returns (uint) {
  (uint l, uint h) = fullMul (x, y);
  require (h < z);

  uint mm = mulmod (x, y, z);
  if (mm > l) h -= 1;
  l -= mm;

  uint pow2 = z & -z;
  z /= pow2;
  l /= pow2;
  l += h * ((-pow2) / pow2 + 1);

  uint r = 1;
  r *= 2 - z * r;
  r *= 2 - z * r;
  r *= 2 - z * r;
  r *= 2 - z * r;
  r *= 2 - z * r;
  r *= 2 - z * r;
  r *= 2 - z * r;
  r *= 2 - z * r;

  return l * r;
}
```

è¯¥å‡½æ•°ä¸­ï¼Œæ¯æ¬¡`mulDiv`è°ƒç”¨ä»…æ¶ˆè€—çº¦ 550 gasï¼Œå¹¶ä¸”å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–ã€‚ è¿™æ¯”å­¦æ ¡é‡Œå­¦åˆ°çš„æ•°å­¦æ–¹æ³•å¥½ 5 å€ï¼Œä¸è¦å¤ª nbï¼ ä½†æ˜¯ï¼Œå®é™…ä¸Šåªæœ‰æ•°å­¦åšå£«æ‰èƒ½ç¼–å†™è¿™æ ·çš„ä»£ç ï¼Œå¹¶ä¸”å¹¶éæ¯ä¸ªé—®é¢˜éƒ½å…·æœ‰è¿™æ ·çš„æ•°å­¦è§£å†³æ–¹æ¡ˆã€‚ å¦‚æœæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æµ®ç‚¹æ•°ï¼Œé—®é¢˜ä¼šå˜å¾—å¾ˆç®€å•ï¼š

# åœ¨ Solidity ä¸­ä½¿ç”¨æµ®ç‚¹æ•°

å°±åƒæˆ‘ä»¬åœ¨æœ¬æ–‡å¼€å¤´è¯´è¿‡çš„é‚£æ ·ï¼Œç”¨ JavaScript åªéœ€ç¼–å†™`a * b / c`ï¼Œå…¶ä½™éƒ¨åˆ†å°±ç”±è¯¥è¯­è¨€å¤„ç†ã€‚ æˆ‘ä»¬æ”¹å¦‚ä½•åœ¨ Solidity ä¸­å®ç°ç±»ä¼¼çš„åŠŸèƒ½?

å®é™…ä¸Šè¿™æ˜¯å¯ä»¥çš„ã€‚è™½ç„¶æ ¸å¿ƒè¯­è¨€ä¸æ”¯æŒæµ®ç‚¹æ•°ï¼Œä½†æœ‰äº›åº“æ”¯æŒã€‚ ä¾‹å¦‚ï¼Œä½¿ç”¨[ABDKMathQuad](https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMathQuad.md)åº“ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿™æ ·å†™ä»£ç ï¼š

```
function mulDiv (uint x, uint y, uint z)
public pure returns (uint) {
  return
    ABDKMathQuad.toUInt (
      ABDKMathQuad.div (
        ABDKMathQuad.mul (
          ABDKMathQuad.fromUInt (x),
          ABDKMathQuad.fromUInt (y)
        ),
        ABDKMathQuad.fromUInt (z)
      )
    );
}
```

è¿™ç§æ–¹æ³•ä¸åƒ JavaScript é‚£æ ·ä¼˜é›…ï¼Œä¹Ÿä¸å¦‚æ•°å­¦è§£å†³æ–¹æ¡ˆé‚£æ ·ä¾¿å®œ,ä½†æ˜¯å®ƒç®€å•è€Œç²¾ç¡®,å› ä¸ºè¿™é‡Œä½¿ç”¨çš„å››ç²¾åº¦æµ®ç‚¹æ•°å¤§çº¦æœ‰ 33 ä½æœ‰æ•ˆå°æ•°ã€‚

æ­¤æ–¹æ³•è¶…è¿‡ä¸€åŠçš„ gas æ¶ˆè€—ç”¨äºå°†`uint`å€¼è¿›è¡Œæµ®ç‚¹æ•°å’Œæ— ç¬¦å·æ•´æ•°çš„ç›¸äº’è½¬æ¢ï¼Œæ¯”ä¾‹è®¡ç®—æœ¬èº«ä»…æ¶ˆè€—çº¦ 1.4K gasã€‚ å› æ­¤ï¼Œåœ¨æ‰€æœ‰æ™ºèƒ½åˆçº¦ä¸­ä½¿ç”¨æµ®ç‚¹æ•°å¯èƒ½æ¯”æ··ç”¨æ•´æ•°å’Œæµ®ç‚¹æ•°ä¾¿å®œå¾—å¤šã€‚

# ç»“è®º

ç”±äº Solidity å­˜åœ¨æº¢å‡ºé—®é¢˜ï¼Œå¹¶ä¸”ä¸æ”¯æŒåˆ†æ•°ï¼›ç™¾åˆ†æ•°å’Œæ¯”ä¾‹è®¡ç®—åœ¨ Solidity ä¸­æ¯”è¾ƒå¤æ‚ã€‚ä½†æ˜¯,å¯ä»¥ä½¿ç”¨å„ç§æ•°å­¦æŠ€å·§æœ‰æ•ˆåœ°è§£å†³è¿™äº›é—®é¢˜ã€‚

ä½¿ç”¨åº“æ”¯æŒçš„æµ®ç‚¹æ•°ä¼šå°†é—®é¢˜ç®€åŒ–å¾ˆå¤šï¼Œä½†åŒæ—¶ä¹Ÿä¼šå¢åŠ  gas æ¶ˆè€—å¹¶ç‰ºç‰²ç²¾åº¦ã€‚

åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ›´æ·±å…¥åœ°ç ”ç©¶é‡‘èæ•°å­¦ï¼Œä¸‹ä¸€ä¸ªä¸»é¢˜å°†æ˜¯ï¼š [**å¤åˆ©**](/coinmonks/math-in-solidity-part-4-compound-interest-512d9e13041b)ã€‚

åŸæ–‡é“¾æ¥ï¼šhttps://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1
ä½œè€…ï¼š[Mikhail Vladimirov](https://medium.com/@mikhail.vladimirov)
